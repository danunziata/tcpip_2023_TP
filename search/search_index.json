{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Smart Green House","text":""},{"location":"#resumen","title":"Resumen","text":"<p>El proyecto del Invernadero Inteligente es una implementaci\u00f3n innovadora que utiliza tecnolog\u00eda IoT (Internet of Things) para mejorar la producci\u00f3n agr\u00edcola a trav\u00e9s del control preciso del entorno de cultivo en invernaderos. El objetivo principal es optimizar las condiciones ambientales para lograr una producci\u00f3n de calidad y maximizar la eficiencia de los recursos.</p> <p>La industria agr\u00edcola enfrenta desaf\u00edos significativos debido a la dificultad de realizar pron\u00f3sticos claros y a la dependencia de la intuici\u00f3n de los expertos. Para superar estas limitaciones, nuestro equipo ha sido contratado por una importante empresa del sector AgTech para implementar un Invernadero Inteligente utilizando tecnolog\u00eda IoT.</p> <p>El Invernadero Inteligente est\u00e1 dise\u00f1ado para monitorear y controlar de cerca par\u00e1metros cr\u00edticos como la temperatura, humedad, intensidad de luz y di\u00f3xido de carbono. Estos datos se adquieren a trav\u00e9s de sensores inal\u00e1mbricos y de una API de pron\u00f3stico del tiempo.</p> <p>Una vez adquiridos los datos, se utiliz\u00f3 un programa en Python para procesarlos y enviarlos a un servidor en la nube a trav\u00e9s del protocolo MQTT. El servidor, implementado en la plataforma ThingsBoard, proporciona una interfaz gr\u00e1fica personalizada para visualizar y controlar los datos del invernadero, as\u00ed como una base de datos para almacenar la informaci\u00f3n recopilada.</p> <p>Adem\u00e1s, se utiliz\u00f3 la herramienta Ngrok para establecer una conexi\u00f3n segura y remota entre la Raspberry Pi, que act\u00faa como computadora central, y el servidor en la nube. Esto permite el monitoreo y control del Invernadero Inteligente desde cualquier ubicaci\u00f3n.</p> <p>El proyecto del Invernadero Inteligente representa un avance significativo en la agricultura de precisi\u00f3n, brindando una soluci\u00f3n tecnol\u00f3gica que optimiza la producci\u00f3n agr\u00edcola y supera las limitaciones de la intuici\u00f3n humana. Aunque no se pudo implementar la parte de hardware con sensores reales de di\u00f3xido de carbono, se utiliz\u00f3 una API de pron\u00f3stico del tiempo para simular esta informaci\u00f3n y obtener una visi\u00f3n completa del entorno del invernadero.</p> <p>A lo largo de este sitio de documentaci\u00f3n, encontrar\u00e1s informaci\u00f3n detallada sobre los requisitos, dise\u00f1o, implementaci\u00f3n y servicios relacionados con el proyecto del Invernadero Inteligente. Explora los diferentes apartados para conocer m\u00e1s sobre c\u00f3mo se ha desarrollado este innovador sistema y c\u00f3mo puede mejorar la producci\u00f3n agr\u00edcola de manera sostenible y eficiente.</p> <p>\u00a1Bienvenido al proyecto del Invernadero Inteligente!</p>"},{"location":"broker/","title":"Mosquitto Broker","text":""},{"location":"broker/#introduccion","title":"Introduccion","text":"<p>Eclipse Mosquitto es un broker de mensajes de c\u00f3digo abierto (con licencia EPL/EDL) que implementa las versiones 5.0, 3.1.1 y 3.1 del protocolo MQTT. Mosquitto es ligero y es adecuado para su uso en todos los dispositivos, desde ordenadores de placa \u00fanica de baja potencia hasta servidores completos.</p>"},{"location":"broker/#instalacion-del-servicio","title":"Instalacion del servicio","text":"<p>Para poder utilizar el servicio debemos instalarlo en nuestro servidor</p> <pre><code>sudo apt-get update\nsudo apt-get install mosquitto\nsudo apt-get install mosquitto-clients\n</code></pre>"},{"location":"broker/#archivo-de-configuracion","title":"Archivo de configuracion","text":"<p>Este archivo contiene todas las funcionalidades que se van a activar en el broker para su utilizacion, este archivo se llama config.conf y estara ubicado en la carpeta /etc/mosquitto/conf.d</p> <pre><code>#permite a los clientes sin usuario conectarse\nallow_anonymous true\n#puerto el cual escucha peticiones el broker\nlistener 1883\n#marca el inicio de una nueva conexi\u00f3n bridge\nConnection mybridge\n\n#Especifica la direcci\u00f3n y opcionalmente el puerto del bridge al que se va a conectar\naddress red:puerto\n\n#Define el id del cliente para la conexi\u00f3n\nremote_clientid admin\n\n#Define el usuario del broker a conectarse\nremote_username fede\n\n#Define la contrase\u00f1a del broker a conectarse\nremote_password 123\n#El bridge le intentar\u00e1 indicar al broker remoto que es un conexion bridge y no un cliente, pero como no queremos eso lo ponemos en false\ntry_private false\n#Controla como inicia la conexion el bridge, en este caso se conecta autom\u00e1ticamente y se reinicia cada 30 segundos\nstart_type automatic\n\n#Define los patrones de temas que se compartir\u00e1n entre los 2 brokers.\ntopic v1/devices/me/rpc/request/+ both 1\ntopic # both 1\n</code></pre>"},{"location":"broker/#inicio-del-servicio","title":"Inicio del servicio","text":"<p>Para comenzar y monitoriar el servicio broker utilizamos el siguiente comando</p> <pre><code>mosquitto -v -c /etc/mosquitto/conf.d/config.conf\n</code></pre>"},{"location":"dsg/","title":"Design","text":""},{"location":"dsg/#resumen","title":"Resumen","text":"<p>La secci\u00f3n de dise\u00f1o del documento se enfoca en la planificaci\u00f3n y especificaci\u00f3n del sistema del Invernadero Inteligente. En esta etapa, se establecen las bases para la implementaci\u00f3n del proyecto, definiendo los elementos clave y la estructura del sistema.</p> <p>El dise\u00f1o del Invernadero Inteligente se ha dividido en tres niveles de construcci\u00f3n para organizar y detallar los aspectos relevantes del sistema. Estos niveles proporcionan una visi\u00f3n jer\u00e1rquica que permite comprender mejor la arquitectura y la funcionalidad del sistema.</p> <ul> <li>Nivel L0, entradas y salidas del sistema.</li> <li>Nivel L1, bloques especificos del sistema.</li> <li>Nivel L2, descripcion detallada de los bloques en el nivel L1.</li> </ul>"},{"location":"dsg/#documento-de-diseno","title":"Documento de Dise\u00f1o","text":"<p>Descargar PDF</p>"},{"location":"imp/","title":"Implementation","text":""},{"location":"imp/#resumen","title":"Resumen","text":"<p>La secci\u00f3n proporcionada del documento de implementaci\u00f3n se enfoca en la descripci\u00f3n detallada de los bloques clave que deben ponerse en pr\u00e1ctica en el proyecto del Invernadero Inteligente. Estos bloques representan las etapas fundamentales del funcionamiento del sistema y se definen de la siguiente manera:</p> <ul> <li>Bloque de Adquisicion de Datos.</li> <li>Bloque de Procesamiento de Datos.</li> <li>Bloque de Interfaz de Usuario.</li> <li>Base de Datos.</li> <li>Bloque de Recepcion de Datos.</li> </ul>"},{"location":"imp/#documento-de-implementacion","title":"Documento de Implementaci\u00f3n","text":"<p>Descargar PDF</p>"},{"location":"req/","title":"Requirements","text":""},{"location":"req/#resumen","title":"Resumen","text":"<p>La secci\u00f3n del documento de requisitos se centra en los planteamientos surgidos durante las conversaciones con los contratantes del servicio para el proyecto del Invernadero Inteligente. En esta secci\u00f3n, se realiza una descripci\u00f3n detallada de los requisitos espec\u00edficos que deben ser abordados en el proyecto.</p> <p>El documento de requisitos se divide en dos partes principales para organizar y definir claramente los objetivos del proyecto.</p> <ul> <li>Requisitos de Alto Nivel.</li> <li>Requisitos de Bajo Nivel.</li> </ul>"},{"location":"req/#documento-de-requisitos","title":"Documento de Requisitos","text":"<p>Descargar PDF</p>"},{"location":"sensor/","title":"ESP8266","text":""},{"location":"sensor/#introduccion","title":"Introduccion","text":"<p>El ESP8266 es un chip Wi-Fi de bajo coste con pila TCP/IP completa y capacidad de MCU (Micro Controller Unit) producida por el fabricante chino Espressif Systems, con sede en Shanghai.</p> <p>Utilizaremos el ESP8266 para conectarlo junto a los sensores y actuadores para poder asi recolectar e enviar los datos al broker local y recibir informacion del mismo para poder tomar decisiones con la informacion dada.</p> <p>En nuestro caso, ponemos a disposicion 2 scripts que cuentan con implementaciones de python diferentes.</p>"},{"location":"sensor/#cpython","title":"CPython","text":"<p>Haremos uso de la libreria paho-mqtt que cuenta con todas las funcionalidades para disponer de la comunicacion a traves del protocolo MQTT.</p> <pre><code>import paho.mqtt.client as mqtt     # import client library\nimport time\nimport json\nimport requests\n# Funcion para simular las condiciones del invernadero\ndef tempActual():\nglobal temp\nglobal humedad\nglobal co2\nurl = 'http://api.weatherapi.com/v1/current.json?key=2367a071311c47f684d211141230207&amp;q=Rio Cuarto&amp;aqi=yes'\nresponse = requests.get(url)\ncontent = response.json()\ntemp = content['current']['temp_c']\nhumedad = content['current']['humidity']\nco2 = content['current']['air_quality']['co']\n# Funciones Callbacks\ndef on_connect(client, userdata, flags, rc):\nif rc == 0:  # Codigo de Error = 0, exitoso\nprint(\"Se Ha Conectado y Estamos listos para operar\")\nclient.connected_flag = True\nelse:  # Nos indica que hay algun error\nprint(\"Bad connection Returned code=\", rc)\nclient.bad_connection_flag = True\ndef on_publish(client, userdata, mid):\nprint(\"Datos enviados:\", mid)  # Nos confirma que los datos fueron enviados\ndef on_subscribe(client, userdata, mid, granted_qos):\nprint(\"Suscripciones satisfactorias\")  # Suscripciones exitosas\ndef on_message(client, userdata, message):  # Le indicamos que hacer en cada caso\nglobal message_received\ntime.sleep(1)\nmessage_received = str(message.payload.decode(\"utf-8\"))\n# Recibimos el mensaje y lo pasamos a JSON\nmsg = json.loads(message_received)\nprint(\"received message =\", message_received)\nif msg['method'] == \"setValue\":  # Opcion 1: Cambio en la intensidad de la Luz\ndatos = {\n\"Lumonosidad\": msg[\"params\"]\n}\nserial = json.dumps(datos)\nclient.publish(topic_telemetry, serial, qos=1)\nif msg['method'] == \"setValue2\":  # Opcion 2: Cambio en el Led\ndatos = {\n\"value\": msg[\"params\"]\n}\nserial = json.dumps(datos)\nclient.publish(topic_telemetry, serial, qos=1)\ndef on_disconnect(client, userdata, rc):\n# Cliente desconectado exitosamente\nprint(\"El cliente se ha desconectado exitosamente\")\n# Flags a utilizar\nmqtt.Client.connected_flag = False\nmqtt.Client.bad_connection_flag = False\n# Parametros A Utilizar\nhost = \"192.168.5.216\"  # host del Broker\nid = \"fede\"\ntopic_rpc = \"v1/devices/me/rpc/request/+\"\ntopic_telemetry = \"v1/devices/me/telemetry\"\n# Script Principal\nclient = mqtt.Client(id)  # Creamos el Objeto\n# Asignamos los distintos Funciones a los callbacks\nclient.on_connect = on_connect\nclient.on_publish = on_publish\nclient.on_subscribe = on_subscribe\nclient.on_message = on_message\nclient.on_disconnect = on_disconnect\n# Comienza el Loop y nos encargamos de la suscripcion y conexion\nclient.loop_start()  # Empieza el Loop\nprint(\"Conectandose al Host:\", host)\nclient.connect(host)  # Conexion al Broker\nwhile not client.connected_flag and not client.bad_connection_flag:  # Esperamos la conexion\nprint(\"Esperando la Conexion...\")\ntime.sleep(2)\nprint(\"Suscribiendome a los topics asignados...\")\nclient.subscribe(topic_rpc, 1)\n# Carga de Datos cada 5 Segundos\ntry:\nwhile True:\ntempActual()\ndatos = {\n\"Humedad\": humedad,\n\"Temperatura\": temp,\n\"Dioxido de Carbono\": co2\n}\nserial = json.dumps(datos)\nclient.publish(topic_telemetry, serial, qos=1)\ntime.sleep(300)\n# Una vez que se apaga el sistema a traves de la interfaz\n# Detiene el Loop y realiza la desconexion\nexcept KeyboardInterrupt:\nprint(\"\")\nclient.disconnect()\nclient.loop_stop()\ntime.sleep(3)\n</code></pre>"},{"location":"sensor/#micropython","title":"MicroPython","text":"<p>La adaptacion del script anterior se utiliza con una libreria denominada umqttsimple</p> <pre><code>import gc\nimport network\nimport time\nimport machine\nimport urequests\nimport json\nimport uasyncio\nfrom umqttsimple import MQTTClient\nimport esp\nesp.osdebug(None)\ngc.collect()\n# Funcion para obtener los datos de temperatura, humedad y co2\ndef datosActual():\nglobal temp\nglobal humedad\nglobal co2\nurl = 'http://api.weatherapi.com/v1/current.json?key=2367a071311c47f684d211141230207&amp;q=Rio_Cuarto&amp;aqi=yes'\nresponse = urequests.get(url)\ncontent = response.json()\ntemp = content['current']['temp_c']\nhumedad = content['current']['humidity']\nco2 = content['current']['air_quality']['co']\n# Funcion que va a tratar los datos recibidos\ndef sub_cb(topic, msg):\nglobal message_received\ntime.sleep(1)\nmessage_received = str(msg.decode(\"utf-8\"))\n# Recibimos el mensaje y lo pasamos a JSON\nmsg = json.loads(message_received)\nprint(\"received message =\", message_received)\nif msg['method'] == \"setValue\":  # Opcion 1: Cambio en la intensidad de la Luz\ndatos = {\n\"Lumonosidad\": msg[\"params\"]\n}\nserial = json.dumps(datos)\nclient.publish(topic_telemetry, serial, qos=1)\nif msg['method'] == \"setValue2\":  # Opcion 2: Cambio en el Led\ndatos = {\n\"value\": msg[\"params\"]\n}\nserial = json.dumps(datos)\nclient.publish(topic_telemetry, serial, qos=1)\n# Conexion y suscripcion\ndef connect_and_subscribe():\nglobal client_id, mqtt_server, topic_rpc\nclient = MQTTClient(client_id, mqtt_server)\nclient.set_callback(sub_cb)\nclient.connect()\nclient.subscribe(topic_rpc, qos=1)\nprint('Connected to %s MQTT broker, subscribed to %s topic' %\n(mqtt_server, topic_rpc))\nreturn client\n# En caso de fallo...\ndef restart_and_reconnect():\nprint('Failed to connect to MQTT broker. Reconnecting...')\ntime.sleep(10)\nmachine.reset()\n# Definimos las 2 tareas las cuales son:\n# Envio periodico de datos\n# Procesamiento y envio de comprobacion\nasync def waitmsg(delay):\nwhile True:\nclient.check_msg()\nawait uasyncio.sleep(delay)\nasync def main():\nuasyncio.create_task(waitmsg(1))\nwhile True:\ntry:\ndatosActual()\ndatos = {\n\"Humedad\": humedad,\n\"Temperatura\": temp,\n\"Dioxido de Carbono\": co2\n}\nserial = json.dumps(datos)\nclient.publish(topic_telemetry, serial)\nexcept OSError as e:\nrestart_and_reconnect()\nawait uasyncio.sleep(10)\n# Nos conectamos a la red\nssid = \"LabRedes\"\npw = \"labredes\"\nmqtt_server = \"192.168.5.216\"\nclient_id = \"fede\"\ntopic_rpc = \"v1/devices/me/rpc/request/+\"\ntopic_telemetry = \"v1/devices/me/telemetry\"\nsta_if = network.WLAN(network.STA_IF)\nsta_if.active(True)\nif not sta_if.isconnected():\nprint('connecting to network...')\nsta_if.connect('LabRedes', 'labredes')\nwhile not sta_if.isconnected():\npass\nprint('network config:', sta_if.ifconfig())\n# Conectamos al broker\ntry:\nclient = connect_and_subscribe()\nexcept OSError as e:\nrestart_and_reconnect()\n# Inicializamos las tareas\ntry:\nuasyncio.run(main())\nexcept KeyboardInterrupt:\nprint(\"\")\nclient.disconnect()\nprint(\"El cliente se ha desconectado exitosamente\")\ntime.sleep(5)\n</code></pre>"},{"location":"server/","title":"Server","text":""},{"location":"server/#thingsboard","title":"ThingsBoard","text":""},{"location":"server/#introduccion","title":"Introduccion","text":"<p>ThingsBoard es una plataforma IoT de c\u00f3digo abierto para la recolecci\u00f3n, procesamiento, visualizaci\u00f3n y gesti\u00f3n de dispositivos. Permite la conectividad de dispositivos a trav\u00e9s de protocolos est\u00e1ndar de IoT como MQTT, CoAP y HTTP, y admite implementaciones tanto en la nube como en local. ThingsBoard combina escalabilidad, tolerancia a fallos y rendimiento para que nunca pierdas tus datos.</p>"},{"location":"server/#instalacion-del-servicio","title":"Instalacion del servicio","text":"<p>Para instalar el servidor hacemos uso de la plataforma Docker que es una plataforma de contenedores que permite la creaci\u00f3n, distribuci\u00f3n y ejecuci\u00f3n de aplicaciones de forma eficiente y port\u00e1til. Proporciona un entorno aislado para cada aplicaci\u00f3n, facilitando la gesti\u00f3n y la escalabilidad de los servicios, sin depender del sistema operativo subyacente. Utilizaremos docker compose por lo tanto haremos uso del archivo de configuracion en formato .yml</p> <pre><code>version: \"3.0\"\nservices:\n  mytb:\n    restart: always\n    image: \"thingsboard/tb-postgres\"\n    ports:\n      - \"8080:9090\"\n      - \"1883:1883\"\n      - \"7070:7070\"\n      - \"5683-5688:5683-5688/udp\"\n    environment:\n      TB_QUEUE_TYPE: in-memory\n    volumes:\n      - ~/.mytb-data:/data\n      - ~/.mytb-logs:/var/log/thingsboard\n</code></pre> <p>Necesitamos tambien crear carpetas que contengan los datos y logs del sistema</p> <pre><code>mkdir -p ~/.mytb-data &amp;&amp; sudo chown -R 799:799 ~/.mytb-data\nmkdir -p ~/.mytb-logs &amp;&amp; sudo chown -R 799:799 ~/.mytb-logs\n</code></pre> <p>Para ponerlo en funcionamiento ejecutamos los comandos:</p> <pre><code>docker compose up -d\ndocker compose logs -f mytb\n</code></pre>"},{"location":"server/#ngrok","title":"Ngrok","text":""},{"location":"server/#introduccion_1","title":"Introduccion","text":"<p>Ngrok es una herramienta que permite crear t\u00faneles seguros desde internet hacia una red local. Act\u00faa como un intermediario entre la red p\u00fablica y una computadora local, permitiendo acceder a servicios y aplicaciones alojados localmente desde cualquier lugar. Ngrok asigna una URL \u00fanica que redirige el tr\u00e1fico externo a trav\u00e9s de un canal seguro hasta el servidor local. Esto facilita la exposici\u00f3n de servicios locales para pruebas, demostraciones o acceso remoto. Ngrok es ampliamente utilizado en desarrollo web, pruebas de aplicaciones y en entornos de colaboraci\u00f3n remota.</p>"},{"location":"server/#instalacion-del-servicio_1","title":"Instalacion del servicio","text":"<p>Para realizar un tunel debemos crear una cuenta e instalar el servicio en el servidor con el comando:</p> <pre><code>curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc &gt;/dev/null &amp;&amp; echo \"deb https://ngrok-agent.s3.amazonaws.com buster main\" | sudo tee /etc/apt/sources.list.d/ngrok.list &amp;&amp; sudo apt update &amp;&amp; sudo apt install ngrok\n</code></pre> <p>Una vez realizamos la autentificacion en el servicio</p> <pre><code>ngrok config add-authtoken &lt;token&gt;\n</code></pre> <p>Utilizamos un archivo de configuracion para poder crear 1 tunel con 2 servicios simultaneos, uno para la interfaz grafica y otra para la comunicacion por MQTT</p> <p>config.conf</p> <p>Por ultimo, ponemos en marcha el servicio</p> <pre><code>ngrok start -all\n</code></pre>"},{"location":"test/","title":"Testing","text":""},{"location":"test/#resumen","title":"Resumen","text":"<p>El documento de testing se centra en la verificaci\u00f3n y validaci\u00f3n de los objetivos establecidos en el documento de requisitos y la evaluaci\u00f3n de la implementaci\u00f3n del proyecto del Invernadero Inteligente. Su objetivo principal es comprobar que los objetivos planteados hayan sido ejecutados de manera correcta y que el sistema funcione de acuerdo con las especificaciones establecidas.</p> <p>En este documento, se replantean los objetivos iniciales establecidos en el documento de requisitos y se realizan pruebas exhaustivas para verificar su cumplimiento. Se eval\u00faa cada uno de los bloques y componentes implementados, incluyendo el bloque de adquisici\u00f3n de datos, el bloque de procesamiento de datos, el bloque de interfaz de usuario, la base de datos y el bloque de recepci\u00f3n de datos.</p>"},{"location":"test/#documento-de-testing","title":"Documento de Testing","text":"<p>Descargar PDF</p>"}]}